<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Blog Name</title>
  <subtitle>Blog subtitle</subtitle>
  <id>http://blog.url.com/</id>
  <link href="http://blog.url.com/"/>
  <link href="http://blog.url.com/feed.xml" rel="self"/>
  <updated>2016-07-07T17:00:00-07:00</updated>
  <author>
    <name>Blog Author</name>
  </author>
  <entry>
    <title>Heroku CLI Plugins and You</title>
    <link rel="alternate" href="http://blog.url.com/blog/2016/07/08/heroku-plugins.html"/>
    <id>http://blog.url.com/blog/2016/07/08/heroku-plugins.html</id>
    <published>2016-07-07T17:00:00-07:00</published>
    <updated>2016-07-11T21:58:12-07:00</updated>
    <author>
      <name>Article Author</name>
    </author>
    <content type="html">&lt;p&gt;We as developers are working in a golden age of programming where pushing code has never been easier. My personal favorite place to deploy things is &lt;a href="https://heroku.com"&gt;Heroku&lt;/a&gt; because of its customizability, clear (and cheap) pricing structure, and powerful tools.&lt;/p&gt;

&lt;p&gt;The most powerful place developers interact with the Heroku platform is on the command line. The recent release of a new version of their &lt;a href="https://github.com/heroku/cli"&gt;CLI&lt;/a&gt; gave me a great excuse to rewrite an abandoned plugin that I relied on. Unfortunately, save a pair of very helpful doc pages, there were relatively few resources on some of the corner cases you hit while developing a plugin. Here, I'll aim to guide you through some of them.&lt;/p&gt;

&lt;p&gt;If you want to follow along, I'd recommend installing the cli &lt;a href="https://toolbelt.heroku.com/"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id="so-you-want-to-write-a-plugin"&gt;So You Want to Write a Plugin&lt;/h2&gt;

&lt;p&gt;The point of developing a plugin is to add functionality to the Heroku CLI. Plugins usually hit the Heroku API and have the advantage of taking the burden of auth off of your shoulders.&lt;/p&gt;

&lt;p&gt;As a starting point, I'd recommend going through their article &lt;a href="https://devcenter.heroku.com/articles/developing-cli-plug-ins"&gt;Developing CLI Plugins&lt;/a&gt;. It's got a great tutorial which spins you up on the general structure of a plugin. I'm aiming to provide detail to parts of that, but I won't just retype what they've already said. So, if you feel like you've missed stuff, bounce over there once in a while.&lt;/p&gt;

&lt;h3 id="cli-command-structure"&gt;CLI Command Structure&lt;/h3&gt;

&lt;p&gt;Heroku commands are run with the prefix &lt;code&gt;heroku&lt;/code&gt; paired with a &lt;strong&gt;topic&lt;/strong&gt; and optionally, a &lt;strong&gt;command&lt;/strong&gt;. Your plugin will add new commands to topics (existing or your own). Interestingly, you can overwrite default commands (such as &lt;code&gt;config:add&lt;/code&gt;), though I'd &lt;strong&gt;strongly&lt;/strong&gt; recommend against it. Running &lt;code&gt;heroku help&lt;/code&gt; gives you a brief overview of all the available topics:&lt;/p&gt;

&lt;p&gt;```
% heroku help
Usage: heroku COMMAND [–app APP] [command-specific-options]&lt;/p&gt;

&lt;p&gt;Primary help topics, type "heroku help TOPIC" for more details:&lt;/p&gt;

&lt;p&gt;addons    #  manage add-on resources
  apps      #  manage apps (create, destroy)
  auth      #  authentication (login, logout)
  config    #  manage app config vars
  …
```&lt;/p&gt;

&lt;p&gt;If you're going to create a new topic, your module will need to export a &lt;code&gt;topic&lt;/code&gt; object in addition to the command(s). &lt;sup id="fnref:1"&gt;&lt;a href="#fn:1" class="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;h3 id="plugin-layout"&gt;Plugin Layout&lt;/h3&gt;

&lt;p&gt;At the end of the day, your plugin's &lt;code&gt;main&lt;/code&gt; file will need to export a &lt;code&gt;Command&lt;/code&gt; object (or an array of them). The full set of keys you can use is &lt;a href="https://devcenter.heroku.com/articles/developing-cli-plug-ins#all-command-options"&gt;here&lt;/a&gt;, but there are a few you'll most likely need:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Key&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
      &lt;th&gt;Usage&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;topic&lt;/td&gt;
      &lt;td&gt;string&lt;/td&gt;
      &lt;td&gt;CLI category your command(s) fall under (eg. &lt;strong&gt;config&lt;/strong&gt;:pull)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;command&lt;/td&gt;
      &lt;td&gt;string&lt;/td&gt;
      &lt;td&gt;the command name (eg. config:&lt;strong&gt;pull&lt;/strong&gt;)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;description&lt;sup id="fnref:2"&gt;&lt;a href="#fn:2" class="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/td&gt;
      &lt;td&gt;string&lt;/td&gt;
      &lt;td&gt;help that pops up when &lt;code&gt;heroku help &amp;lt;topic&amp;gt;&lt;/code&gt; is run&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;needsApp&lt;/td&gt;
      &lt;td&gt;bool&lt;/td&gt;
      &lt;td&gt;whether or not the command will act upon a specific app (either inferred or specified). Defaults to false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;needsAuth&lt;/td&gt;
      &lt;td&gt;bool&lt;/td&gt;
      &lt;td&gt;whether or not the command needs write access to the app. Defaults to false&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;flags&lt;/td&gt;
      &lt;td&gt;object&lt;/td&gt;
      &lt;td&gt;defines the settings your command can be run with&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;run&lt;/td&gt;
      &lt;td&gt;function&lt;/td&gt;
      &lt;td&gt;the main function for your command)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id="the-function-itself"&gt;The Function Itself&lt;/h3&gt;

&lt;p&gt;You pass &lt;code&gt;Command.run&lt;/code&gt; a function which is the actual functionality of your command. This function is passed just one argument, &lt;code&gt;context&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
module.exports = {
  topic: 'do',
  command: 'things',
  description: 'does things',
  needsApp: false,
  flags: [{
    name: 'file',
    char: 'f',
    hasValue: true,
    description: 'specify target filename'
  }],
  run: function(context) {
    console.log(context)
  }
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;That object contains info about the command, the app (if provided), and environment in which the command is run. It looks like this when run from a plugin in development:&lt;/p&gt;

&lt;p&gt;```javascript
// command: heroku do:things -f cool_file.txt&lt;/p&gt;

&lt;p&gt;{ topic: null,
  command: &lt;COMMAND_OBJECT&gt;,
  app: '&lt;SPECIFIED_APP_NAME&gt;',
  args: [],
  flags: { file: 'cool_file.txt' },
  cwd: '/Users/&lt;USERNAME&gt;/path/to/directory',
  herokuDir: '/Users/&lt;USERNAME&gt;/.cache/heroku',
  debug: false,
  debugHeaders: false,
  dev: true,
  supportsColor: true,
  version: 'heroku-cli/5.2.24-4b7e305 (darwin-amd64) go1.6.2 heroku-config/1.0.2 node-v6.2.1',
  apiToken: '&lt;API_TOKEN&gt;',
  apiHost: 'api.heroku.com',
  apiUrl: 'https://api.heroku.com',
  gitHost: 'heroku.com',
  httpGitHost: 'git.heroku.com',
  auth: { password: '&lt;API_TOKEN&gt;' } }
```&lt;/API_TOKEN&gt;&lt;/API_TOKEN&gt;&lt;/USERNAME&gt;&lt;/USERNAME&gt;&lt;/SPECIFIED_APP_NAME&gt;&lt;/COMMAND_OBJECT&gt;&lt;/p&gt;

&lt;p&gt;The keys you'll use most often are &lt;code&gt;args&lt;/code&gt; and &lt;code&gt;flags&lt;/code&gt;, but there's other helpful things there as well (such as whether or not the command is run in development mode).&lt;/p&gt;

&lt;p&gt;Chances are you'll want to interact with the Heroku API in your plugin. You'll note that &lt;code&gt;context&lt;/code&gt; has auth information for the user, but rather than learn the entire Heroku API and auth methods yourself, they've conveniently provided an authenticated API wrapper. To access this, include the &lt;code&gt;heroku-cli-util&lt;/code&gt; module and wrap your function in the &lt;code&gt;.command()&lt;/code&gt; method  like so:&lt;/p&gt;

&lt;p&gt;```javascript
const cli = require('heroku-cli-util')&lt;/p&gt;

&lt;p&gt;module.exports = {
  topic: 'do',
  command: 'things',
  description: 'does things',
  needsApp: true,
  needsAuth: true,
  flags: [{
    name: 'file',
    char: 'f',
    hasValue: true,
    description: 'specify target filename'
  }],
  run: cli.command((context, heroku) =&amp;gt; {
    return heroku.get('/&lt;AUTH_REQUIRED_ROUTE&gt;').then((data) =&amp;gt; {
      cli.debug(data)
    })
  })
}
```&lt;/AUTH_REQUIRED_ROUTE&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;heroku&lt;/code&gt; is an authenticated instance of their &lt;a href="https://github.com/heroku/node-heroku-client#usage"&gt;api client&lt;/a&gt;. HTTP calls created this way will return a promise. Make sure to return your promise chain at the end of your function so whatever is running the command (either the CLI or tests) handles it correctly.&lt;/p&gt;

&lt;h3 id="should-you-use-generators"&gt;Should You Use Generators?&lt;/h3&gt;

&lt;p&gt;That's a good question! The docs &lt;a href="https://devcenter.heroku.com/articles/developing-cli-plug-ins#using-the-heroku-api"&gt;recommend&lt;/a&gt; doing so for code clarity, and I tend to agree.  Instead of having a chain of promises your asynchronous code looks remarkably synchronous.&lt;/p&gt;

&lt;p&gt;There are a &lt;a href="https://davidwalsh.name/es6-generators"&gt;lot&lt;/a&gt; of &lt;a href="https://alexperry.io/javascript/2015/09/17/es6-generators-and-asynchronous-javascript.html"&gt;great&lt;/a&gt; resources available for learning the in-depth details of how generators work, but you can definitely get by without them. The quick and dirty of it is this:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;You declare a generator function by preceding the name with an asterisk&lt;/li&gt;
  &lt;li&gt;Inside that function, you can &lt;code&gt;yield&lt;/code&gt; certain structures (a function, promise, generator, array, or object), which will pause the function until they're fulfilled. Arrays and objects will process all their requests in parallel and are a great way to perform multiple requests.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Generators work really well with the &lt;code&gt;co&lt;/code&gt; module because it provides a lot of syntactic sugar and control-flow options, making everything place nicely together. You can read more about it &lt;a href="https://github.com/tj/co"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;That's really it! Using generators, we can rewrite the code from before more cleanly:&lt;/p&gt;

&lt;p&gt;```javascript
const cli = require('heroku-cli-util')
const co = require('co')&lt;/p&gt;

&lt;p&gt;module.exports = {
  topic: 'do',
  command: 'things',
  description: 'does things',
  needsApp: true,
  needsAuth: true,
  flags: [{
    name: 'file',
    char: 'f',
    hasValue: true,
    description: 'specify target filename'
  }],
  run: cli.command(co.wrap(function* (context, heroku) {
    let data = yield heroku.get('/&lt;AUTH_REQUIRED_ROUTE&gt;')
    cli.debug(data)
  }))
}
```&lt;/AUTH_REQUIRED_ROUTE&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;co.wrap()&lt;/code&gt; function takes a generator and turns it into a regular function that returns a promise, perfect for our previous code that expects a regular promise-returning function anyway.&lt;/p&gt;

&lt;h3 id="surfacing-errors"&gt;Surfacing Errors&lt;/h3&gt;

&lt;p&gt;One of the big gotchas for using &lt;code&gt;co&lt;/code&gt; is that errors get eaten &lt;a href=""&gt;silently&lt;/a&gt;. Luckily, &lt;code&gt;yield&lt;/code&gt; statements work great with your standard javascript &lt;code&gt;try/catch&lt;/code&gt; block!&lt;/p&gt;

&lt;p&gt;&lt;code&gt;javascript
cli.command(co.wrap(function* (context, heroku) {
  try {
    let data = yield heroku.get('/&amp;lt;AUTH_REQUIRED_ROUTE&amp;gt;')
    cli.debug(data)
  } catch (err) =&amp;gt; {
    cli.exit(1, err)
  }
}))
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Did you catch that last bit? The &lt;code&gt;cli&lt;/code&gt; package provides a helpful &lt;code&gt;exit()&lt;/code&gt; method for when things go sour. It takes an error code&lt;sup id="fnref:3"&gt;&lt;a href="#fn:3" class="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt; and a description of the issue. This approach to errors has the clear advantage of quitting any execution in addition to printing an error message to the user.&lt;/p&gt;

&lt;h3 id="shipping-your-plugin"&gt;Shipping Your Plugin&lt;/h3&gt;

&lt;p&gt;They've got pretty concise instructions for that &lt;a href="https://devcenter.heroku.com/articles/developing-cli-plug-ins#releasing-plugins"&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Your plugin doesn't have to be named &lt;code&gt;heroku-NAME&lt;/code&gt;, but it will help people find it! In either case, any npm package can be installed with &lt;code&gt;heroku plugins:install NAME&lt;/code&gt; (though that command will fail if the installed plugin isn't exporting a well-formatted Heroku plugin).&lt;/p&gt;

&lt;h2 id="tldr"&gt;tl;dr&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href="https://devcenter.heroku.com/articles/developing-cli-plug-ins"&gt;This article&lt;/a&gt; is wildly helpful&lt;/li&gt;
  &lt;li&gt;Export a &lt;a href="https://devcenter.heroku.com/articles/developing-cli-plug-ins#all-command-options"&gt;command&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Return a promise from your main function (if doing any async work) or use ES6 generators (with &lt;code&gt;co&lt;/code&gt;)&lt;/li&gt;
  &lt;li&gt;Wrap yield statements in a &lt;code&gt;try/catch&lt;/code&gt; block and use &lt;code&gt;cli.exit()&lt;/code&gt; to surface errors&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That's all I've got. Hope you've enjoyed wetting your whiskers with the Heroku CLI. Definitely reach out to me on Twitter (&lt;a href="https://www.twitter.com/xavdid"&gt;@xavdid&lt;/a&gt;) with questions or feedback. Happy hacking!&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;em&gt;Full disclosure: Heroku is owned by the same company (Salesforce) that I was formerly employed by. That being said, I used and enjoyed their services long before I was a SFDC employee and the time I put into this was my own.&lt;/em&gt;&lt;/p&gt;

&lt;div class="footnotes"&gt;
  &lt;ol&gt;
    &lt;li id="fn:1"&gt;
      &lt;p&gt;Near as I can tell, a &lt;code&gt;topic&lt;/code&gt; object has only the &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;description&lt;/code&gt; keys, the latter of which is what pops up in the index when &lt;code&gt;heroku help&lt;/code&gt; is run. &lt;a href="#fnref:1" class="reversefootnote"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id="fn:2"&gt;
      &lt;p&gt;the &lt;code&gt;help&lt;/code&gt; flag is similar, but provides a longer description. It shows up when you run &lt;code&gt;heroku help &amp;lt;TOPIC&amp;gt;:&amp;lt;COMMAND&amp;gt;&lt;/code&gt; &lt;a href="#fnref:2" class="reversefootnote"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id="fn:3"&gt;
      &lt;p&gt;You can provide any integer as the error code. Conventionally, &lt;code&gt;0&lt;/code&gt; means success and anything else (most commonly &lt;code&gt;1&lt;/code&gt;) means there was an error. If you want your command to play nicely in a scripting environment, &lt;code&gt;1&lt;/code&gt; is a great choice regardless of the content of the error &lt;a href="#fnref:3" class="reversefootnote"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;
</content>
  </entry>
</feed>
